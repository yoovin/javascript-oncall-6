### 미션 해결 전략

#### 1. 본인이 이해하고 구현한 내용에 기반해 '다른 근무자와 순서를 바꿔야 하는 경우'를 자신만의 예시를 들어 설명하세요. (필수)

다른 근무자와 순서를 바꾸는데 while문을 사용해서 사람을 교체하였을때 또 연속하는 경우가 생기는지를 따져야하는지 고민하였지만, 각 스케쥴 별 근무자의 순서에는 중복이 없다는 점을 토대로 한번만 바꿔주더라도 다음 근무와 겹치지 않는다는 것을 알았습니다.

그래서 hashmap인 object를 이용해 누가 누구랑 순서를 바꿨는지 change log를 저장해두었고 바꿔준 사람의 순서에 도달하였을때 change log에 바꿔준 기록이 남아있으면 해당 인원이 대신 근무를 하는 방식으로 구현했습니다.

- 평일 근무자 준팍, 도밥, 솔로스타, 고니, 수아, 루루
- 휴일 근무자 준팍, 솔로스타, 고니, 도밥, 수아, 루루

예를들어, 이런 순서의 경우, 평일 주말 주말 평일 평일 평일 주말 주말 평일 휴일의 순서로 진행한다면
-> 의 경우 교체된 케이스
1. 준팍
2. 준팍 -> 솔로스타
3. 솔로스타 -> 준팍
4. 도밥
5. 솔로스티
6. 고니
7. 고니 -> 도밥
8. 도밥 -> 고니
9. 수아
10. 수아 -> 루루

상당한 교체가 진행됨에도 두명끼리만으로 수월하게 근무표가 생성되며, 인접해있는 두 근로자끼리 변경되더라도 이전날과 겹치지 않습니다.

#### 2. 요구사항에서 제시한 앞의 날짜부터 순서를 변경하는 방법 외에 다른 방법이 있다면 어떤 방식이 있는지, 이 방법은 기존에 제시된 방식과 비교해 어떤 차이가 있는지 설명하세요. (선택)

연속으로 서게 되는 경우, 그 스케쥴 배열에서 해당 근로자를 맨 뒤로 보내는 방법이 있을 수 있겠습니다.
이러한 경우, 한 사람이 다시 근무하는데까지 다소 시간이 걸릴 수 있지만, 간편하게 연속되는 날을 제거하며 코드로 구현하기 쉬울 것 같습니다.

기존 방식은 누가 누구랑 바꾸었는지 기록을 해두며 한 사람이 중복해서 근무를 하지 않을 수 있었지만, 이를 기록하기위해 추가적으로 메모리를 소모하였습니다. 배열의 요소를 수정하는 방식으로 진행한다면, 추가적으로 메모리를 사용하지 않고 문제를 해결할 수 있을 것 같습니다.
